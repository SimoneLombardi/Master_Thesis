%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2345678901234567890123456789012345678901234567890123456789012345678901234567890
%        1         2         3         4         5         6         7         8
% THESIS CHAPTER

\chapter{Methodology}
\label{chap:third}
\graphicspath{{Chapter3/Figures/PNG/}{Chapter3/Figures/JPG/}{Chapter3/Figures/}}


\section{Task Priority}
Continuing the discussion from \ref{equat:TaskPrioritiClassic_generalSolution}, the classic task priority algorithm as explained in \cite{simetti2016novel} lacks the ability to smoothly activate and deactivate \textit{inequality} task when the robot is far from the activation region.
The approach that I implemented is based on the definition of a new \textit{regularized pseudo-inversion operator} that integrates the \textit{activation function} as a weight matrix to modulate the intensity of the action taken for a specific task.
The operator is defined as:
\begin{equation}
	\vec{X}^{\#,\vec{A},\vec{Q}} \triangleq (\vec{X}^T\vec{A}\vec{X} + \eta(\vec{I}-\vec{Q})^T(\vec{I}-\vec{Q}) + \vec{V}^T\vec{P}\vec{V})^{\#} \vec{X}^T\vec{A}\vec{A}
	\label{equat:RegPseudoInverse_operator}
\end{equation}
where the matrix $\vec{V}$ is the right orthonormal matrix of the SVD decomposition for     $\vec{X}^T\vec{A}\vec{X}+\eta(\vec{I}-\vec{Q})^T(\vec{I}-\vec{Q})$.
The compact expression of the algorithm becomes, for the \textit{k-th} priority level:
\begin{equation}
	\begin{aligned}
		\vec{W}_k &= \vec{J}_k\vec{Q}_{k-1}(\vec{J}_k\vec{Q}_{k-1})^{\#,\vec{A}_k,\vec{Q}_{k-1}} \\
		\vec{Q}_k &= \vec{Q}_{k-1}(\vec{I}-(\vec{J}_k\vec{Q}_{k-1})^{\#,\vec{A}_k,\vec{I}}\vec{J}_k\vec{Q}_{k-1}) \\
		\vec{\rho}_k &= \vec{\rho}_{k-1} + \vec{Q}_{k-1}(\vec{J}_k\vec{Q}_{k-1})^{\#,\vec{A}_k,\vec{I}}\vec{W}_k(\vec{\dot{x}}-\vec{J}_k\vec{\rho}_{k-1})
	\end{aligned}
\end{equation}


\subsection{Task Description}
In this section I will describe the mathematical formulation of the task I implemented in my control loop. To simplify the notation all the matrices, if not stated otherwise, are projected on the $\langle\textit{kuka\_base}\rangle$ reference frame.


\subsection{Obstacle Avoidance}
For the \textit{Obstacle Avoidance} task I used the approach proposed in \cite{maciejewski1985obstacle}, after computing the point of the robot body at \textit{minimum sitance} from the obstacle, I used said point to apply a  desired velocity in the direction directly opposite to the distance vector.
% single point
\\ \noindent \textbf{Task reference}:\\
\noindent The \textit{distance} vector and the \textit{point} are retrieved in a topic, and are already projected in the $\langle\textit{kuka\_base}\rangle$ reference frame.\\
\begin{equation}
	d = (P_o - P_r)\hspace{0.5cm};\hspace{0.5cm}\dot{\vec{\bar{r}}} = -d
\end{equation}
\noindent
Since in the original paper the \textit{planar} and \textit{spatial} case are treated separatley, in chap.\ref{chap:fifth} I will experiment with both the vector as is, and with a zeroed out $z$ component. To understand how the proposed approach behaves in the two cases. \\

\noindent \textbf{Activation function}: \\
Since this is a \textit{inequality} task, we want to avoid overconstraining the system. To do so I employed a smooth activation function, whose value change from $0$ to $1$ as the distance from the obstacle gets closer to the threshold.
The the activation value is computed as follows:\\
\begin{equation}
	a = 
	\begin{cases}
		1 &  x < x_{min} \\[5pt]
		\frac{1}{2}[(\cos(\pi\frac{x-x_{min}}{\delta})+1)] & x\in[x_{min},x_{min}+\delta] \\[5pt]
		0 &  x > x_{min} + \delta
	\end{cases}
\end{equation}
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.2]{DecreasingActFcn.jpg}
	\caption{Generic activation function}
	\label{fig:DecreasingActFcn}
\end{figure}
\noindent
For the \textit{obstacle avoidance} task the activation function is a diagonal $3\times 3$ matrix, that has a different activation value for each component of the \textit{distance} vector.
\noindent
Here is an example of an activation profile for the \textit{obstacle avoidance} task, the \textit{saturation} distance si set to $10$cm, while the transition region has lenght $\delta = 50$cm.\\ 

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.2]{DecreasingActFcn_realValues_obav.jpg}
	\caption{Activation for Obstacle avoidance}
	\label{fig:DecreasingActFcn_realValues_obav}
\end{figure}
It is clear that as the \textit{distance} goes to $0$ the activation values increases, saturating at $1$ for \textit{distances} lower than $10$cm.

\noindent \textbf{Task Jacobian}:\\
For this task, different \textit{jacobian} matrices must be computed depending on the link on which the \textit{minimum distance point} is located. To handle this efficiently, the jacobians are constructed \textit{colum} by \textit{colum}, resulting in a more compact and readable implementation. I used the same method throughout my thesis.\\
\noindent 
In particular, the colum relative to the $i-th$ link is computed as:\\
\begin{equation}
	\leftindex^{kb}{\vec{J}}_{i/kb} = 
	\begin{pmatrix}
		\leftindex^{kb}{\vec{J}}_{i/kb}^{L} \\[4pt]
		\leftindex^{kb}{\vec{J}}_{i/kb}^{A}
	\end{pmatrix} =
	\begin{pmatrix}
		\vec{R}^{kb}_i \cdot \textit{ax}_i \times (r^{kb}_n - r^{kb}_i) \\[8pt]
		\vec{R}^{kb}_i \cdot \textit{ax}_i
	\end{pmatrix}
	\label{equat:AnalyticJacobianFormula}
\end{equation}
\\
\noindent
where $\textit{ax}_i$ is the axes of rotation for joint i expressed in the joint frame, which I retrieved from the \codetxt{darkgray}{urdf} description of the two robots. 
\noindent
Taken the complete jacobian of the $12$Dof structure I pre-multiplied for the rigid body jacobian, which is computed as:
\begin{equation}
	\leftindex^{kb}{\vec{J}}_{mdp/kb} = 
	\begin{pmatrix}
		\leftindex^{kb}{\vec{J}}_{mdp/kb}^{L} \\[4pt]
		\leftindex^{kb}{\vec{J}}_{mdp/kb}^{A}
	\end{pmatrix} =
	\begin{pmatrix}
		\vec{I}_{3\times 3} & [r_{mdp/i}\times]^T \\[4pt]
		\vec{0}_{3\times 3} & \vec{I}_{3\times 3}
	\end{pmatrix} \cdot
	\begin{pmatrix}
		\leftindex^{kb}{\vec{J}}_{i/kb}^{L} \\[4pt]
		\leftindex^{kb}{\vec{J}}_{i/kb}^{A}
	\end{pmatrix} 
\end{equation}\\
\textit{mdp}:\textit{minimum distance point}, and \textit{i}: link that contains the \textit{mdp}

% set based task

\subsection{End Effector Target}
This is the \textit{goal-driven task} in my simulation of the working environment.
\\ \\
\noindent \textbf{Task reference}:\\
In this case the task reference is the \textit{cartesian error} between the \textit{tool} frame and the \textit{end-effector} frame.
Computed in the simulation using the \textit{transformation buffer}, starting from names of the \textit{end effector} and \textit{tool} frame the translation error:
\begin{equation}
	err_{goal/tool}^{L} = \leftindex^{kb}{(P_g - P_t)}
\end{equation}
all projected in the end effector frame. For the angular error I use the quaternion expression of the two rotation matrices:
\begin{equation}
	\vec{R}_{goal}^{kb} = \rho_{goal} \hspace{0,25cm};\hspace{0,25cm} \vec{R}_{tool}^{kb} = \rho_{tool}
\end{equation}
I than compute the error using the quaternions that gives:
\begin{equation}
	\rho_{err} = \rho_{goal}^{-1} \cdot \rho_{tool}
\end{equation}
lastly this I took the vector part of this quaternion to multiply to the rotation $\vec{R}_{tool}^{kb}$:
\begin{equation}
	\rho_{err} = 
	\begin{pmatrix}
		x_e \\
		y_e \\
		z_e \\
		w_e
	\end{pmatrix} =
	\begin{pmatrix}
		\vec{v}_e \\
		w_e
	\end{pmatrix}
	\hspace{0,25cm};\hspace{0,25cm}
	\vec{v}_e = \vec{u}\sin\left(\frac{\theta}{2}\right)
\end{equation}
and $\vec{v}_e$ is proportional to the angle error, for small angle. The vector I used as \textit{angular part} of the cartesian error is:	
\begin{equation}
	err_{goal/tool}^{A} = - \vec{R}_{tool}^{kb} \vec{v}_e
\end{equation}

\noindent \textbf{Activation function}: \\
Since this in an \textit{equality task} it has to be always active. And given the dimension of its \textit{reference rate}: $\dot{\bar{x}} \in \mathbb{R}^{6\times 1}$ the activation function is a identity matrix.
\begin{equation}
	\vec{A} = \vec{I} \in \mathbb{R}^{6\times 6}
\end{equation}
\noindent \textbf{Task Jacobian}:\\
The task jacobian is the \textit{complete geometric jacobian} for the \textit{end effector}, computed as shown in \ref{equat:AnalyticJacobianFormula}.

\subsubsection{Goal broadcasting}
As the \textit{end effector} target for the \textit{reaching} task I perform a series of transformation from the initial message that is sent trough the \textit{Action server} as two vectors:
\begin{align}
	\vec{r} = \begin{pmatrix}
		x \\
		y \\
		z
	\end{pmatrix}
	\hspace{8pt} \text{;} \hspace{8pt}
	\vec{\rho} = \begin{pmatrix}
		\phi \\
		\theta \\
		\psi
	\end{pmatrix}
\end{align}

The first represent the desired translation, and the desired rotation as \textit{roll, pitch, yaw} angles.
The projection frames of this vector to define the goal position and orientation could be either the \textit{end effector} frame, or, the \textit{kuka base} frame. This was done for experimental purposes, for easly sequencing different goals, or to repeat reaching tasks to a specific position in the environment.

For the orientation of the goal, $\vec{\rho}$ is used to compose the rotation matrix that is than projected on the desired frame:
\begin{align}
	\vec{R}_{goal} &= \vec{R}_{z}(\psi) \cdot \vec{R}_{y}(\theta) \cdot \vec{R}_{x}(\phi) \\[4pt]
	\langle\textit{kuka\_base}\rangle: \leftindex^{kb}{\vec{R}}_{goal} &= \vec{I} \cdot \vec{R}_{goal} \\
	\langle\textit{end\_effector}\rangle: \leftindex^{ee}{\vec{R}}_{goal} &= \vec{R}_{ee}^{kb} \cdot \vec{R}_{goal}
\end{align}
In the first case the projection matrix is the identity since $\langle\textit{kuka\_base}\rangle \equiv \langle\textit{world}\rangle$.
Same process is done for the translation vector:
\begin{align}
	\langle\textit{kuka\_base}\rangle: \leftindex^{kb}{\vec{r}}_{goal} &= \vec{0} + \vec{r}_{goal}\\
	\langle\textit{end\_effector}\rangle: \leftindex^{ee}{\vec{r}}_{goal} &= \vec{r}_{ee}^{kb} + \vec{r}_{goal}
\end{align}
Than the rotation matrix and the translation vector are use to publish the $\langle\textit{goal}\rangle$ in rviz.

\subsection{Joint limits}

\subsection{End Effector minimum altitude}
This task is used to keep the end effector away from the floor. I implemented this task to check the correctness of the \textit{task priority} algorithm, to have a more predictable task with which I could better asses the expected behavior of the system.\\
\\ \\
\textbf{Task reference}:\\
\noindent 
The reference rate for this task is computed using the $z$ coordinate of the traslation from the $\langle\textit{kuka\_base}\rangle$ frame to $\langle\textit{end\_effector}\rangle$. 
\begin{equation}
	\textit{Reference rate: } \dot{\bar{x}}_z = \lambda \cdot (\vec{\bar{x}} + \delta - \vec{z}_{ee}^{kb})
\end{equation}
The complete vector has all zero exept on the $z$ coordinate.
\begin{equation}
	\textit{Reference rate: } \vec{\dot{\bar{x}}} = [0, 0, \dot{\bar{x}}_z, 0, 0, 0]^T
\end{equation}
\\
\noindent The \textit{Reference rate} is considered as the \textit{desired shape} of the derivative of the variable I want to control.
To be more precise:
\begin{itemize}
	\item if $x > \bar{x}$ then $\dot{x} < 0$
	\item if $x < \bar{x}$ then $\dot{x} > 0$
	\item if $x = \bar{x}$ then $\dot{x} = 0$
\end{itemize}
In the case of the \textit{Minimual altitude task} the variable I want to control is the $z$ of the \textit{end effector} of the robot, and to impose a minimum altitude $z_{min}$. Finally the $\delta$ keeps count of the activation region, meaning that the task will be smoothly activated starting from $z_{min} + \delta$ to $z_{min}$.
\\ \\
\noindent \textbf{Activation function}: \\

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.2]{DecreasingActFcn_realValues.jpg}
	\caption{With realistic values}
	\label{fig:DecreasingActFcn_rv}
\end{figure}
In this case I used a $(6 \times 6)$ zero matrix as my activation function, than I inserted the value in the third position of the major diagonal, ending up with:
\begin{equation}
	\vec{A}_{min alt} = \textit{diag} (0, 0, a_z, 0, 0, 0)
\end{equation}
using $z_min = 0,30$\textit{m} as my lower limit and $\delta = 0,1$\textit{m}, and the function is tuned to yield $y \in [0,1]$.
\\ \\
\noindent \textbf{Task Jacobian}:\\
The task jacobian is equal to the third row of the \textit{geometric jacobian} of the robot, to compute it I used the same method described in \ref*{equat:AnalyticJacobianFormula} with no rigid body trasformation.


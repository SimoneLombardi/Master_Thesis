%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2345678901234567890123456789012345678901234567890123456789012345678901234567890
%        1         2         3         4         5         6         7         8
% THESIS CHAPTER

\chapter{Methodology}
\label{chap:fourth}
\graphicspath{{Chapter4/Figures/PNG/}{Chapter4/Figures/JPG/}{Chapter4/Figures/JPEG/}{Chapter4/Figures/}}
in this chapter I will describe in detail the mathematical computation performed by the control algorithm I developed. 

\section{Goal broadcasting}
The architecture works in a \textit{position reaching} framework, a goal position for the \textit{end effector} is sent to the robot and the algorithm tries to reach said position, with constraint given by other tasks.
The goal is sent using the \textit{action server} build in the \textit{JointRobotTP} class, in the form of two vectors:
\begin{align}
	\vec{r} = \begin{pmatrix}
			x \\
			y \\
			z
	\end{pmatrix}
	\hspace{8pt} \text{;} \hspace{8pt}
	\vec{\rho} = \begin{pmatrix}
		\phi \\
		\theta \\
		\psi
	\end{pmatrix}
\end{align}

The first represent the desired translation, and the desired rotation as \textit{roll, pitch, yaw} angles.
The projection frames of this vector to define the goal position and orientation could be either the \textit{end effector} frame, or, the \textit{kuka base} frame. This was done for experimental purposes, for easly sequencing different goals, or to repeat reaching tasks to a specific position in the environment.

For the orientation of the goal, $\vec{\rho}$ is used to compose the rotation matrix that is than projected on the desired frame:
\begin{align}
	\vec{R}_{goal} &= \vec{R}_{z}(\psi) \cdot \vec{R}_{y}(\theta) \cdot \vec{R}_{x}(\phi) \\[4pt]
	\langle\textit{kuka\_base}\rangle: \leftindex^{kb}{\vec{R}}_{goal} &= \vec{I} \cdot \vec{R}_{goal} \\
	\langle\textit{end\_effector}\rangle: \leftindex^{ee}{\vec{R}}_{goal} &= \vec{R}_{ee}^{kb} \cdot \vec{R}_{goal}
\end{align}
In the first case the projection matrix is the identity since $\langle\textit{kuka\_base}\rangle \equiv \langle\textit{world}\rangle$.
Same process is done for the translation vector:
\begin{align}
	\langle\textit{kuka\_base}\rangle: \leftindex^{kb}{\vec{r}}_{goal} &= \vec{0} + \vec{r}_{goal}\\
	\langle\textit{end\_effector}\rangle: \leftindex^{ee}{\vec{r}}_{goal} &= \vec{r}_{ee}^{kb} + \vec{r}_{goal}
\end{align}
Than the rotation matrix and the translation vector are use to publish the $\langle\textit{goal}\rangle$ in rviz.
\section{Task Priority}
Continuing the discussion from \ref{equat:TaskPrioritiClassic_generalSolution}, the classic task priority algorithm as explained in \cite{simetti2016novel} lacks the ability to smoothly activate and deactivate \textit{inequality} task when the robot is far from the activation region.
The approach that I implemented is based on the definition of a new \textit{regularized pseudo-inversion operator} that integrates the \textit{activation function} as a weight matrix to modulate the intensity of the action taken for a specific task.
The operator is defined as:
\begin{equation}
	\vec{X}^{\#,\vec{A},\vec{Q}} \triangleq (\vec{X}^T\vec{A}\vec{X} + \eta(\vec{I}-\vec{Q})^T(\vec{I}-\vec{Q}) + \vec{V}^T\vec{P}\vec{V})^{\#} \vec{X}^T\vec{A}\vec{A}
	\label{equat:RegPseudoInverse_operator}
\end{equation}
where the matrix $\vec{V}$ is the right orthonormal matrix of the SVD decomposition for     $\vec{X}^T\vec{A}\vec{X}+\eta(\vec{I}-\vec{Q})^T(\vec{I}-\vec{Q})$.
The compact expression of the algorithm becomes, for the \textit{k-th} priority level:
\begin{equation}
	\begin{aligned}
		\vec{W}_k &= \vec{J}_k\vec{Q}_{k-1}(\vec{J}_k\vec{Q}_{k-1})^{\#,\vec{A}_k,\vec{Q}_{k-1}} \\
		\vec{Q}_k &= \vec{Q}_{k-1}(\vec{I}-(\vec{J}_k\vec{Q}_{k-1})^{\#,\vec{A}_k,\vec{I}}\vec{J}_k\vec{Q}_{k-1}) \\
		\vec{\rho}_k &= \vec{\rho}_{k-1} + \vec{Q}_{k-1}(\vec{J}_k\vec{Q}_{k-1})^{\#,\vec{A}_k,\vec{I}}\vec{W}_k(\vec{\dot{x}}-\vec{J}_k\vec{\rho}_{k-1})
	\end{aligned}
\end{equation}


\subsection{Task Description}
In this section I will describe the mathematical formulation of the task I implemented in my control loop. To simplify the notation all the matrices, if not stated otherwise, are projected on the $\langle\textit{kuka\_base}\rangle$ reference frame.

\subsubsection{End Effector minimum altitude}
This task is used to keep the end effector away from the floor.\\
\\ \\
\textbf{Task reference}:\\
\noindent 
The reference rate for this task is computed using the $z$ coordinate of the traslation from the $\langle\textit{kuka\_base}\rangle$ frame to $\langle\textit{end\_effector}\rangle$. 
\begin{equation}
	\textit{Reference rate: } \dot{\bar{x}}_z = \lambda \cdot (\vec{\bar{x}} + \delta - \vec{z}_{ee}^{kb})
\end{equation}
The complete vector has all zero exept on the $z$ coordinate.
\begin{equation}
	\textit{Reference rate: } \vec{\dot{\bar{x}}} = [0, 0, \dot{\bar{x}}_z, 0, 0, 0]^T
\end{equation}
\\
\noindent The \textit{Reference rate} is considered as the \textit{desired shape} of the derivative of the variable I want to control.
To be more precise:
\begin{itemize}
	\item if $x > \bar{x}$ then $\dot{x} < 0$
	\item if $x < \bar{x}$ then $\dot{x} > 0$
	\item if $x = \bar{x}$ then $\dot{x} = 0$
\end{itemize}
In the case of the \textit{Minimual altitude task} the variable I want to control is the $z$ of the \textit{end effector} of the robot, and to impose a minimum altitude $z_{min}$. Finally the $\delta$ keeps count of the activation region, meaning that the task will be smoothly activated starting from $z_{min} + \delta$ to $z_{min}$.
\\ \\
\noindent \textbf{Activation function}: \\
\noindent To avoid the abrupt activation of the task that could lead to chattering around the treshold, and more importantly to avoid the over constraining of the system we also add a smooth \textit{activation function}.

\begin{equation}
	a = 
	\begin{cases}
		1 &  x < x_{min} \\[5pt]
		\frac{1}{2}[(\cos(\pi\frac{x-x_{min}}{\delta})+1)] & x\in[x_{min},x_{min}+\delta] \\[5pt]
		0 &  x > x_{min} + \delta
	\end{cases}
\end{equation}

\begin{figure}[H]
	\centering
	\begin{subfigure}{0.49\textwidth}
		\includegraphics[width=\linewidth]{DecreasingActFcn.jpg}
		\caption{Generic function}
		\label{fig:DecreasingActFcn}
	\end{subfigure}
	\hfill
	\begin{subfigure}{0.49\textwidth}
		\includegraphics[width=\linewidth]{DecreasingActFcn_realValues.jpg}
		\caption{With realistic values}
		\label{fig:DecreasingActFcn_rv}
	\end{subfigure}
\end{figure}
In this case I used a $(6 \times 6)$ zero matrix as my activation function, than I inserted the value in the third position of the major diagonal, ending up with:
\begin{equation}
	\vec{A}_{min alt} = \textit{diag} (0, 0, a_z, 0, 0, 0)
\end{equation}
using $z_min = 0,30$\textit{m} as my lower limit and $\delta = 0,1$\textit{m}, and the function is tuned to yield $y \in [0,1]$.
\\ \\
\noindent \textbf{Task Jacobian}\\
\noindent For this task the jacobian matrix is equivalent to the geometric jacobian, computed up to the \textit{end effector} frame. Since the available methods of the classes \codetxt{darkgray}{KukaRobot} and \codetxt{darkgray}{UR10eRobot} compute the jacobians matrices in their respective base frames. Enumeratin the links of the whole robot as $lk_i=1 ... 12$\\
\begin{equation}
	\leftindex^{kb}{\vec{J}}_{6/kb} ; \leftindex^{ub}{\vec{J}}_{12/ub}
\end{equation}
\\
The complete trasformation for computing the Jacobian of the unified structure projected in the kuka base frame is:
\\
\begin{equation}
	content ...
\end{equation}

I decided to build the jacobian colum by colum since it was necessary for the obstacle avoidance task and it allowed for a more clear and concise code. So for computing the colum relative to the $i-th$ link I used the equation:\\
\begin{equation}
	\leftindex^{kb}{\vec{J}}_{i/kb} = 
	\begin{pmatrix}
		\leftindex^{kb}{\vec{J}}_{i/kb}^{L} \\[4pt]
		\leftindex^{kb}{\vec{J}}_{i/kb}^{A}
	\end{pmatrix} =
	\begin{pmatrix}
		\vec{R}^{kb}_i \cdot \textit{ax}_i \times (r^{kb}_n - r^{kb}_i) \\[8pt]
		\vec{R}^{kb}_i \cdot \textit{ax}_i
	\end{pmatrix}
	\label{equat:AnalyticJacobianFormula}
\end{equation}
\\
\noindent
where $\textit{ax}_i$ is the axes of rotation for joint i expressed in the joint frame, which I retrieved from the \codetxt{darkgray}{urdf} description of the two robots. 

\subsubsection{Obstacle Avoidance}
For the \textit{Obstacle Avoidance} task I used the approach proposed in \cite{maciejewski1985obstacle} keeping a single point task were that point is the point at minimum distance from the obstacle in the robot body.
% single point
\\ \noindent \textbf{Task reference}:\\
\noindent As a task reference I used the opposite of the vector connecting the \textit{minimum distance} robot point to the \textit{obstacle point}. \\
\begin{equation}
	d = (P_o - P_r)\hspace{0.5cm};\hspace{0.5cm}\dot{\vec{\bar{r}}} = -d
\end{equation}
In chap.\ref{chap:fifth} I will experiment with both the vector as is, and with a zeroed out $z$ component. To understand how the proposed approach behaves in the 3d and 2d case. \\
\noindent \textbf{Activation function}: \\
The activation function is a $3\times 3$ matrix, and the values are computed in the same fashion as the \textit{minimum altitude} task.
This time the minimum distance is lowered to $10$cm while $\delta = 50$cm, this was to enforce a very smooth activation of the task. The resulting profile is as follows:\\
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.2]{DecreasingActFcn_realValues_obav.jpg}
	\caption{Activation for Obstacle avoidance}
	\label{fig:DecreasingActFcn_realValues_obav}
\end{figure}
\noindent \textbf{Task Jacobian}:\\
For the task jacobian I used the same analytical approach as in the \textit{minimum altitude} task, adding a rigid body to take into consideration the position of the \textit{minimum distance point} on the body of the robot.
Taken the complete jacobian of the $12$Dof structure I pre-multiplied for the rigid body jacobian, which is computed as:
\begin{equation}
	\leftindex^{kb}{\vec{J}}_{mdp/kb} = 
	\begin{pmatrix}
		\leftindex^{kb}{\vec{J}}_{mdp/kb}^{L} \\[4pt]
		\leftindex^{kb}{\vec{J}}_{mdp/kb}^{A}
	\end{pmatrix} =
	\begin{pmatrix}
		\vec{I}_{3\times 3} & [r_{mdp/i}\times]^T \\[4pt]
		\vec{0}_{3\times 3} & \vec{I}_{3\times 3}
	\end{pmatrix} \cdot
	\begin{pmatrix}
		\leftindex^{kb}{\vec{J}}_{i/kb}^{L} \\[4pt]
		\leftindex^{kb}{\vec{J}}_{i/kb}^{A}
	\end{pmatrix} 
\end{equation}\\
\textit{mdp}:\textit{minimum distance point}, and \textit{i}: link that contains the \textit{mdp}

% set based task

\subsubsection{End Effector Target}
This is the \textit{goal-driven task} in my simulation of the working environment.
\\ \\
\noindent \textbf{Task reference}:\\
In this case the task reference is the \textit{cartesian error} between the \textit{tool} frame and the \textit{end-effector} frame.
Computed in the simulation using the \textit{transformation buffer}, starting from names of the \textit{end effector} and \textit{tool} frame the translation error:
\begin{equation}
	err_{goal/tool}^{L} = \leftindex^{kb}{(P_g - P_t)}
\end{equation}
all projected in the end effector frame. For the angular error I use the quaternion expression of the two rotation matrices:
\begin{equation}
	\vec{R}_{goal}^{kb} = \rho_{goal} \hspace{0,25cm};\hspace{0,25cm} \vec{R}_{tool}^{kb} = \rho_{tool}
\end{equation}
I than compute the error using the quaternions that gives:
\begin{equation}
	\rho_{err} = \rho_{goal}^{-1} \cdot \rho_{tool}
\end{equation}
lastly this I took the vector part of this quaternion to multiply to the rotation $\vec{R}_{tool}^{kb}$:
\begin{equation}
	\rho_{err} = 
	\begin{pmatrix}
		x_e \\
		y_e \\
		z_e \\
		w_e
	\end{pmatrix} =
	\begin{pmatrix}
		\vec{v}_e \\
		w_e
	\end{pmatrix}
	\hspace{0,25cm};\hspace{0,25cm}
	\vec{v}_e = \vec{u}\sin\left(\frac{\theta}{2}\right)
\end{equation}
and $\vec{v}_e$ is proportional to the angle error, for small angle. The vector I used as \textit{angular part} of the cartesian error is:	
\begin{equation}
	err_{goal/tool}^{A} = - \vec{R}_{tool}^{kb} \vec{v}_e
\end{equation}

\noindent \textbf{Activation function}: \\
Since this in an \textit{equality task} it has to be always active. And given the dimension of its \textit{reference rate}: $\dot{\bar{x}} \in \mathbb{R}^{6\times 1}$ the activation function is a identity matrix.
\begin{equation}
	\vec{A} = \vec{I} \in \mathbb{R}^{6\times 6}
\end{equation}
\noindent \textbf{Task Jacobian}:\\
The task jacobian is the \textit{complete geometric jacobian} for the \textit{end effector}, computed as shown in \ref{equat:AnalyticJacobianFormula}.
